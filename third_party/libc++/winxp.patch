From 804e92ced666f50d2dc9d6911df6bc26184fe127 Mon Sep 17 00:00:00 2001
From: Chilledheart <hukeyue@hotmail.com>
Date: Fri, 21 Jul 2023 19:17:52 +0800
Subject: [PATCH] allow xp build

---
 .../__condition_variable/condition_variable.h |   4 +
 include/__config                              |   5 +-
 include/__mutex/mutex.h                       |   4 +
 include/__threading_support                   |  46 ++
 include/mutex                                 |  45 ++
 include/thread                                |  45 ++
 src/condition_variable.cpp                    |   7 +
 src/condition_variable_destructor.cpp         |   4 +
 src/memory.cpp                                |   8 +
 src/mutex.cpp                                 |   7 +
 src/mutex_destructor.cpp                      |   5 +
 src/random_shuffle.cpp                        |   3 +
 src/support/win32/thread_win32.cpp            | 459 +++++++++++++++++-
 13 files changed, 631 insertions(+), 11 deletions(-)

diff --git a/include/__condition_variable/condition_variable.h b/include/__condition_variable/condition_variable.h
index 8fc80b6336..c0507781a0 100644
--- a/include/__condition_variable/condition_variable.h
+++ b/include/__condition_variable/condition_variable.h
@@ -41,7 +41,11 @@ class _LIBCPP_TYPE_VIS condition_variable {
   __libcpp_condvar_t __cv_ = _LIBCPP_CONDVAR_INITIALIZER;
 
 public:
+#if !defined(_LIBCPP_MSVCRT)
   _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR condition_variable() _NOEXCEPT = default;
+#else
+  condition_variable() _NOEXCEPT;
+#endif
 
 #  ifdef _LIBCPP_HAS_TRIVIAL_CONDVAR_DESTRUCTION
   ~condition_variable() = default;
diff --git a/include/__config b/include/__config
index 671605864f..cd21708635 100644
--- a/include/__config
+++ b/include/__config
@@ -993,8 +993,7 @@ _LIBCPP_BEGIN_NAMESPACE_STD _LIBCPP_END_NAMESPACE_STD
 //               respective stakeholders.
 // clang-format off
 #  if (defined(_LIBCPP_HAS_THREAD_API_PTHREAD) && defined(__GLIBC__)) ||                                               \
-      (defined(_LIBCPP_HAS_THREAD_API_C11) && defined(__Fuchsia__)) ||                                                 \
-       defined(_LIBCPP_HAS_THREAD_API_WIN32)
+      (defined(_LIBCPP_HAS_THREAD_API_C11) && defined(__Fuchsia__))
 // clang-format on
 #    define _LIBCPP_HAS_TRIVIAL_MUTEX_DESTRUCTION
 #  endif
@@ -1007,7 +1006,7 @@ _LIBCPP_BEGIN_NAMESPACE_STD _LIBCPP_END_NAMESPACE_STD
 //
 // TODO(EricWF): This is potentially true for some pthread implementations
 // as well.
-#  if (defined(_LIBCPP_HAS_THREAD_API_C11) && defined(__Fuchsia__)) || defined(_LIBCPP_HAS_THREAD_API_WIN32)
+#  if (defined(_LIBCPP_HAS_THREAD_API_C11) && defined(__Fuchsia__))
 #    define _LIBCPP_HAS_TRIVIAL_CONDVAR_DESTRUCTION
 #  endif
 
diff --git a/include/__mutex/mutex.h b/include/__mutex/mutex.h
index 819d4f37de..048b4b4058 100644
--- a/include/__mutex/mutex.h
+++ b/include/__mutex/mutex.h
@@ -25,7 +25,11 @@ class _LIBCPP_TYPE_VIS _LIBCPP_THREAD_SAFETY_ANNOTATION(capability("mutex")) mut
   __libcpp_mutex_t __m_ = _LIBCPP_MUTEX_INITIALIZER;
 
 public:
+#if !defined(_LIBCPP_MSVCRT)
   _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR mutex() = default;
+#else
+  mutex() _NOEXCEPT;
+#endif
 
   mutex(const mutex&)            = delete;
   mutex& operator=(const mutex&) = delete;
diff --git a/include/__threading_support b/include/__threading_support
index 08dfd73c0a..a3cc92ce11 100644
--- a/include/__threading_support
+++ b/include/__threading_support
@@ -122,8 +122,19 @@ typedef tss_t __libcpp_tls_key;
 #define _LIBCPP_TLS_DESTRUCTOR_CC
 #elif !defined(_LIBCPP_HAS_THREAD_API_EXTERNAL)
 // Mutex
+#if !defined(_LIBCPP_MSVCRT) || (defined(_LIBCPP_MSVCRT) && (_WIN32_WINNT >= 0x0600))
 typedef void* __libcpp_mutex_t;
 #define _LIBCPP_MUTEX_INITIALIZER 0
+#else
+#if defined(_M_IX86)|| defined(_M_ARM)
+typedef void* __libcpp_mutex_t[6];
+#elif defined(_M_AMD64) || defined(_M_ARM64)
+typedef void* __libcpp_mutex_t[5];
+#else
+# error Unsupported architecture
+#endif
+#define _LIBCPP_MUTEX_INITIALIZER {}
+#endif
 
 #if defined(_M_IX86) || defined(__i386__) || defined(_M_ARM) || defined(__arm__)
 typedef void* __libcpp_recursive_mutex_t[6];
@@ -134,8 +145,19 @@ typedef void* __libcpp_recursive_mutex_t[5];
 #endif
 
 // Condition Variable
+#if !defined(_LIBCPP_MSVCRT) || (defined(_LIBCPP_MSVCRT) && (_WIN32_WINNT >= 0x0600))
 typedef void* __libcpp_condvar_t;
 #define _LIBCPP_CONDVAR_INITIALIZER 0
+#else
+#if defined(_M_IX86)|| defined(_M_ARM)
+typedef void* __libcpp_condvar_t[4+2+6];
+#elif defined(_M_AMD64) || defined(_M_ARM64)
+typedef void* __libcpp_condvar_t[2+2+5];
+#else
+# error Unsupported architecture
+#endif
+#define _LIBCPP_CONDVAR_INITIALIZER {}
+#endif
 
 // Execute Once
 typedef void* __libcpp_exec_once_flag;
@@ -172,6 +194,11 @@ int __libcpp_recursive_mutex_unlock(__libcpp_recursive_mutex_t *__m);
 _LIBCPP_THREAD_ABI_VISIBILITY
 int __libcpp_recursive_mutex_destroy(__libcpp_recursive_mutex_t *__m);
 
+#if defined(_LIBCPP_MSVCRT)
+_LIBCPP_THREAD_ABI_VISIBILITY _LIBCPP_NO_THREAD_SAFETY_ANALYSIS
+int __libcpp_mutex_init(__libcpp_mutex_t *__m);
+#endif
+
 _LIBCPP_THREAD_ABI_VISIBILITY _LIBCPP_NO_THREAD_SAFETY_ANALYSIS
 int __libcpp_mutex_lock(__libcpp_mutex_t *__m);
 
@@ -185,6 +212,11 @@ _LIBCPP_THREAD_ABI_VISIBILITY
 int __libcpp_mutex_destroy(__libcpp_mutex_t *__m);
 
 // Condition variable
+#if defined(_LIBCPP_MSVCRT)
+_LIBCPP_THREAD_ABI_VISIBILITY
+int __libcpp_condvar_init(__libcpp_condvar_t* __cv);
+#endif
+
 _LIBCPP_THREAD_ABI_VISIBILITY
 int __libcpp_condvar_signal(__libcpp_condvar_t* __cv);
 
@@ -202,6 +234,12 @@ _LIBCPP_THREAD_ABI_VISIBILITY
 int __libcpp_condvar_destroy(__libcpp_condvar_t* __cv);
 
 // Execute once
+#if defined(_LIBCPP_MSVCRT)
+_LIBCPP_THREAD_ABI_VISIBILITY
+int __libcpp_execute_once(__libcpp_exec_once_flag *flag,
+                          void *arg,
+                          void (*init_routine)(void*));
+#endif
 _LIBCPP_THREAD_ABI_VISIBILITY
 int __libcpp_execute_once(__libcpp_exec_once_flag *__flag,
                           void (*__init_routine)());
@@ -217,15 +255,23 @@ bool __libcpp_thread_id_less(__libcpp_thread_id __t1, __libcpp_thread_id __t2);
 _LIBCPP_THREAD_ABI_VISIBILITY
 bool __libcpp_thread_isnull(const __libcpp_thread_t *__t);
 
+#if !defined(_LIBCPP_MSVCRT)
 _LIBCPP_THREAD_ABI_VISIBILITY
 int __libcpp_thread_create(__libcpp_thread_t *__t, void *(*__func)(void *),
                            void *__arg);
+#else
+_LIBCPP_THREAD_ABI_VISIBILITY
+int __libcpp_thread_create(__libcpp_thread_t *__t, __libcpp_thread_id* __t_id,
+                           void *(*__func)(void *), void *__arg);
+#endif
 
 _LIBCPP_THREAD_ABI_VISIBILITY
 __libcpp_thread_id __libcpp_thread_get_current_id();
 
+#if !defined(_LIBCPP_MSVCRT)
 _LIBCPP_THREAD_ABI_VISIBILITY
 __libcpp_thread_id __libcpp_thread_get_id(const __libcpp_thread_t *__t);
+#endif
 
 _LIBCPP_THREAD_ABI_VISIBILITY
 int __libcpp_thread_join(__libcpp_thread_t *__t);
diff --git a/include/mutex b/include/mutex
index ed9b43d591..5be4266aa8 100644
--- a/include/mutex
+++ b/include/mutex
@@ -577,7 +577,11 @@ struct _LIBCPP_TEMPLATE_VIS once_flag
 {
     _LIBCPP_INLINE_VISIBILITY
     _LIBCPP_CONSTEXPR
+#if defined(_LIBCPP_MSVCRT)
+        once_flag() _NOEXCEPT : __state_(_LIBCPP_EXEC_ONCE_INITIALIZER) {}
+#else
         once_flag() _NOEXCEPT : __state_(0) {}
+#endif
     once_flag(const once_flag&) = delete;
     once_flag& operator=(const once_flag&) = delete;
 
@@ -658,6 +662,45 @@ __call_once_proxy(void* __vp)
     (*__p)();
 }
 
+#ifdef _LIBCPP_MSVCRT
+
+#ifndef _LIBCPP_CXX03_LANG
+
+template<class _Callable, class... _Args>
+inline _LIBCPP_INLINE_VISIBILITY
+void
+call_once(once_flag& __flag, _Callable&& __func, _Args&&... __args)
+{
+  typedef tuple<_Callable&&, _Args&&...> _Gp;
+  _Gp __f(_VSTD::forward<_Callable>(__func), _VSTD::forward<_Args>(__args)...);
+  __call_once_param<_Gp> __p(__f);
+  __libcpp_execute_once(reinterpret_cast<__libcpp_exec_once_flag*>(&__flag.__state_), &__p, &__call_once_proxy<_Gp>);
+}
+
+#else  // _LIBCPP_CXX03_LANG
+
+template<class _Callable>
+inline _LIBCPP_INLINE_VISIBILITY
+void
+call_once(once_flag& __flag, _Callable& __func)
+{
+   __call_once_param<_Callable> __p(__func);
+   __libcpp_execute_once(reinterpret_cast<__libcpp_exec_once_flag*>(&__flag.__state_), &__p, &__call_once_proxy<_Callable>);
+}
+
+template<class _Callable>
+inline _LIBCPP_INLINE_VISIBILITY
+void
+call_once(once_flag& __flag, const _Callable& __func)
+{
+  __call_once_param<const _Callable> __p(__func);
+  ___libcpp_execute_once(reinterpret_cast<__libcpp_exec_once_flag*>(&__flag.__state_), &__p, &__call_once_proxy<const _Callable>);
+}
+
+#endif // _LIBCPP_CXX03_LANG
+
+#else // _LIBCPP_MSVCRT
+
 _LIBCPP_FUNC_VIS void __call_once(volatile once_flag::_State_type&, void*,
                                   void (*)(void*));
 
@@ -705,6 +748,8 @@ call_once(once_flag& __flag, const _Callable& __func)
 
 #endif // _LIBCPP_CXX03_LANG
 
+#endif // _LIBCPP_MSVCRT
+
 _LIBCPP_END_NAMESPACE_STD
 
 _LIBCPP_POP_MACROS
diff --git a/include/thread b/include/thread
index 7b3b89c335..a09b0d6fe6 100644
--- a/include/thread
+++ b/include/thread
@@ -278,6 +278,9 @@ struct _LIBCPP_TEMPLATE_VIS formatter<__thread_id, _CharT> {
 class _LIBCPP_TYPE_VIS thread
 {
     __libcpp_thread_t __t_;
+#if defined(_LIBCPP_MSVCRT)
+    __libcpp_thread_id __t_id_;
+#endif
 
     thread(const thread&);
     thread& operator=(const thread&);
@@ -299,29 +302,63 @@ public:
 #endif
     ~thread();
 
+#if !defined(_LIBCPP_MSVCRT)
     _LIBCPP_INLINE_VISIBILITY
     thread(thread&& __t) _NOEXCEPT : __t_(__t.__t_) {
         __t.__t_ = _LIBCPP_NULL_THREAD;
     }
+#else
+    _LIBCPP_INLINE_VISIBILITY
+    thread(thread&& __t) _NOEXCEPT : __t_(__t.__t_), __t_id_(__t.__t_id_) {
+        __t.__t_ = _LIBCPP_NULL_THREAD;
+        __t.__t_id_ = 0;
+    }
+#endif
 
+#if !defined(_LIBCPP_MSVCRT)
+    _LIBCPP_INLINE_VISIBILITY
+    thread& operator=(thread&& __t) _NOEXCEPT {
+        if (!__libcpp_thread_isnull(&__t_))
+            terminate();
+        __t_ = __t.__t_;
+        __t.__t_ = _LIBCPP_NULL_THREAD;
+        return *this;
+    }
+#else
     _LIBCPP_INLINE_VISIBILITY
     thread& operator=(thread&& __t) _NOEXCEPT {
         if (!__libcpp_thread_isnull(&__t_))
             terminate();
         __t_ = __t.__t_;
+        __t_id_ = __t.__t_id_;
         __t.__t_ = _LIBCPP_NULL_THREAD;
+        __t.__t_id_ = 0;
         return *this;
     }
+#endif
 
+#if !defined(_LIBCPP_MSVCRT)
     _LIBCPP_INLINE_VISIBILITY
     void swap(thread& __t) _NOEXCEPT {_VSTD::swap(__t_, __t.__t_);}
+#else
+    _LIBCPP_INLINE_VISIBILITY
+    void swap(thread& __t) _NOEXCEPT {
+      _VSTD::swap(__t_, __t.__t_);
+      _VSTD::swap(__t_id_, __t.__t_id_);
+    }
+#endif
 
     _LIBCPP_INLINE_VISIBILITY
     bool joinable() const _NOEXCEPT {return !__libcpp_thread_isnull(&__t_);}
     void join();
     void detach();
+#if !defined(_LIBCPP_MSVCRT)
     _LIBCPP_INLINE_VISIBILITY
     id get_id() const _NOEXCEPT {return __libcpp_thread_get_id(&__t_);}
+#else
+    _LIBCPP_INLINE_VISIBILITY
+    id get_id() const _NOEXCEPT {return __t_id_; }
+#endif
     _LIBCPP_INLINE_VISIBILITY
     native_handle_type native_handle() _NOEXCEPT {return __t_;}
 
@@ -362,7 +399,11 @@ thread::thread(_Fp&& __f, _Args&&... __args)
             new _Gp(_VSTD::move(__tsp),
                     _VSTD::forward<_Fp>(__f),
                     _VSTD::forward<_Args>(__args)...));
+#if !defined(_LIBCPP_MSVCRT)
     int __ec = _VSTD::__libcpp_thread_create(&__t_, &__thread_proxy<_Gp>, __p.get());
+#else
+    int __ec = _VSTD::__libcpp_thread_create(&__t_, &__t_id_, &__thread_proxy<_Gp>, __p.get());
+#endif
     if (__ec == 0)
         __p.release();
     else
@@ -397,7 +438,11 @@ thread::thread(_Fp __f)
     typedef __thread_invoke_pair<_Fp> _InvokePair;
     typedef unique_ptr<_InvokePair> _PairPtr;
     _PairPtr __pp(new _InvokePair(__f));
+#if defined(_LIBCPP_MSVCRT)
     int __ec = _VSTD::__libcpp_thread_create(&__t_, &__thread_proxy_cxx03<_InvokePair>, __pp.get());
+#else
+    int __ec = _VSTD::__libcpp_thread_create(&__t_, &__thread_proxy_cxx03<_InvokePair>, __pp.get());
+#endif
     if (__ec == 0)
         __pp.release();
     else
diff --git a/src/condition_variable.cpp b/src/condition_variable.cpp
index 85f334e024..1f813aaa28 100644
--- a/src/condition_variable.cpp
+++ b/src/condition_variable.cpp
@@ -22,6 +22,13 @@ _LIBCPP_PUSH_MACROS
 
 _LIBCPP_BEGIN_NAMESPACE_STD
 
+#if defined(_LIBCPP_MSVCRT)
+condition_variable::condition_variable() _NOEXCEPT
+{
+    __libcpp_condvar_init(&__cv_);
+}
+#endif
+
 // ~condition_variable is defined elsewhere.
 
 void
diff --git a/src/condition_variable_destructor.cpp b/src/condition_variable_destructor.cpp
index c217a09394..9c6ca5f7e6 100644
--- a/src/condition_variable_destructor.cpp
+++ b/src/condition_variable_destructor.cpp
@@ -28,8 +28,12 @@ class _LIBCPP_TYPE_VIS condition_variable
 {
     __libcpp_condvar_t __cv_ = _LIBCPP_CONDVAR_INITIALIZER;
 public:
+#if !defined(_LIBCPP_MSVCRT)
     _LIBCPP_INLINE_VISIBILITY
     constexpr condition_variable() noexcept = default;
+#else
+    condition_variable() noexcept;
+#endif
 
     ~condition_variable();
 
diff --git a/src/memory.cpp b/src/memory.cpp
index d01d6140d3..807962e485 100644
--- a/src/memory.cpp
+++ b/src/memory.cpp
@@ -152,6 +152,10 @@ static constinit __libcpp_mutex_t mut_back[__sp_mut_count] =
 _LIBCPP_CONSTEXPR __sp_mut::__sp_mut(void* p) noexcept
    : __lx_(p)
 {
+#if defined(_LIBCPP_MSVCRT)
+    auto m = static_cast<__libcpp_mutex_t*>(__lx_);
+    __libcpp_mutex_init(m);
+#endif
 }
 
 void
@@ -170,7 +174,11 @@ __sp_mut::unlock() noexcept
 __sp_mut&
 __get_sp_mut(const void* p)
 {
+#if defined(_LIBCPP_MSVCRT)
+    static __sp_mut muts[__sp_mut_count] = {
+#else
     static constinit __sp_mut muts[__sp_mut_count] = {
+#endif
         &mut_back[ 0], &mut_back[ 1], &mut_back[ 2], &mut_back[ 3],
         &mut_back[ 4], &mut_back[ 5], &mut_back[ 6], &mut_back[ 7],
         &mut_back[ 8], &mut_back[ 9], &mut_back[10], &mut_back[11],
diff --git a/src/mutex.cpp b/src/mutex.cpp
index 9469dcf6c4..aa4bf08a19 100644
--- a/src/mutex.cpp
+++ b/src/mutex.cpp
@@ -25,6 +25,13 @@ _LIBCPP_BEGIN_NAMESPACE_STD
 
 #ifndef _LIBCPP_HAS_NO_THREADS
 
+#if defined(_LIBCPP_MSVCRT)
+mutex::mutex() _NOEXCEPT
+{
+    __libcpp_mutex_init(&__m_);
+}
+#endif
+
 // ~mutex is defined elsewhere
 
 void
diff --git a/src/mutex_destructor.cpp b/src/mutex_destructor.cpp
index 6850b6e6f4..af2005a90d 100644
--- a/src/mutex_destructor.cpp
+++ b/src/mutex_destructor.cpp
@@ -33,8 +33,13 @@ class _LIBCPP_TYPE_VIS mutex
     __libcpp_mutex_t __m_ = _LIBCPP_MUTEX_INITIALIZER;
 
 public:
+#if !defined(_LIBCPP_MSVCRT)
     _LIBCPP_ALWAYS_INLINE _LIBCPP_INLINE_VISIBILITY
     constexpr mutex() = default;
+#else
+    mutex();
+#endif
+
     mutex(const mutex&) = delete;
     mutex& operator=(const mutex&) = delete;
     ~mutex() noexcept;
diff --git a/src/random_shuffle.cpp b/src/random_shuffle.cpp
index e9087a9701..1a0625bc38 100644
--- a/src/random_shuffle.cpp
+++ b/src/random_shuffle.cpp
@@ -26,6 +26,9 @@ unsigned __rs_default::__c_ = 0;
 __rs_default::__rs_default()
 {
 #ifndef _LIBCPP_HAS_NO_THREADS
+#if defined(_LIBCPP_MSVCRT)
+    __libcpp_mutex_init(&__rs_mut);
+#endif
     __libcpp_mutex_lock(&__rs_mut);
 #endif
     __c_ = 1;
diff --git a/src/support/win32/thread_win32.cpp b/src/support/win32/thread_win32.cpp
index f2072b1435..fa962b1f6c 100644
--- a/src/support/win32/thread_win32.cpp
+++ b/src/support/win32/thread_win32.cpp
@@ -11,23 +11,52 @@
 #define WIN32_LEAN_AND_MEAN
 #include <windows.h>
 #include <process.h>
+
+#if _WIN32_WINNT >= _WIN32_WINNT_VISTA
 #include <fibersapi.h>
+#endif
+
+#if defined(_LIBCPP_MSVCRT)
 
 _LIBCPP_BEGIN_NAMESPACE_STD
 
+#if _WIN32_WINNT >= _WIN32_WINNT_VISTA
 static_assert(sizeof(__libcpp_mutex_t) == sizeof(SRWLOCK), "");
 static_assert(alignof(__libcpp_mutex_t) == alignof(SRWLOCK), "");
-
+#else
+static_assert(sizeof(__libcpp_mutex_t) == sizeof(CRITICAL_SECTION), "");
+static_assert(alignof(__libcpp_mutex_t) == alignof(CRITICAL_SECTION), "");
+#endif
 static_assert(sizeof(__libcpp_recursive_mutex_t) == sizeof(CRITICAL_SECTION),
               "");
 static_assert(alignof(__libcpp_recursive_mutex_t) == alignof(CRITICAL_SECTION),
               "");
 
+#if _WIN32_WINNT >= _WIN32_WINNT_VISTA
 static_assert(sizeof(__libcpp_condvar_t) == sizeof(CONDITION_VARIABLE), "");
 static_assert(alignof(__libcpp_condvar_t) == alignof(CONDITION_VARIABLE), "");
-
+#else
+typedef struct {
+  int nwaiters_blocked;
+  int nwaiters_gone;
+  int nwaiters_to_unblock;
+  int reserved;
+  HANDLE sem_block_queue;
+  HANDLE sem_block_lock;
+  CRITICAL_SECTION mtx_unblock_lock;
+} __libcpp_condvar_do_t;
+static_assert(sizeof(__libcpp_condvar_t) == sizeof(__libcpp_condvar_do_t), "");
+static_assert(alignof(__libcpp_condvar_t) == alignof(__libcpp_condvar_do_t), "");
+#define _LIBCPP_SEMAPHORE_MAX (::std::numeric_limits<long>::max())
+#endif
+
+#if _WIN32_WINNT >= _WIN32_WINNT_VISTA
 static_assert(sizeof(__libcpp_exec_once_flag) == sizeof(INIT_ONCE), "");
 static_assert(alignof(__libcpp_exec_once_flag) == alignof(INIT_ONCE), "");
+#else
+static_assert(sizeof(__libcpp_exec_once_flag) >= sizeof(LONG), "");
+static_assert(alignof(__libcpp_exec_once_flag) >= alignof(LONG), "");
+#endif
 
 static_assert(sizeof(__libcpp_thread_id) == sizeof(DWORD), "");
 static_assert(alignof(__libcpp_thread_id) == alignof(DWORD), "");
@@ -68,6 +97,14 @@ int __libcpp_recursive_mutex_destroy(__libcpp_recursive_mutex_t *__m)
   return 0;
 }
 
+#if _WIN32_WINNT >= _WIN32_WINNT_WIN7
+
+int __libcpp_mutex_init(__libcpp_mutex_t *__m)
+{
+  *__m = _LIBCPP_MUTEX_INITIALIZER;
+  return 0;
+}
+
 int __libcpp_mutex_lock(__libcpp_mutex_t *__m)
 {
   AcquireSRWLockExclusive((PSRWLOCK)__m);
@@ -91,7 +128,49 @@ int __libcpp_mutex_destroy(__libcpp_mutex_t *__m)
   return 0;
 }
 
+#else // _WIN32_WINNT >= _WIN32_WINNT_WIN7
+
+int __libcpp_mutex_init(__libcpp_mutex_t *__m)
+{
+  InitializeCriticalSection((LPCRITICAL_SECTION)__m);
+  return 0;
+}
+
+int __libcpp_mutex_lock(__libcpp_mutex_t *__m)
+{
+  EnterCriticalSection((LPCRITICAL_SECTION)__m);
+  return 0;
+}
+
+bool __libcpp_mutex_trylock(__libcpp_mutex_t *__m)
+{
+  return TryEnterCriticalSection((LPCRITICAL_SECTION)__m) != 0;
+}
+
+int __libcpp_mutex_unlock(__libcpp_mutex_t *__m)
+{
+  LeaveCriticalSection((LPCRITICAL_SECTION)__m);
+  return 0;
+}
+
+int __libcpp_mutex_destroy(__libcpp_mutex_t *__m)
+{
+  DeleteCriticalSection((LPCRITICAL_SECTION)__m);
+  return 0;
+}
+
+#endif // _WIN32_WINNT >= _WIN32_WINNT_WIN7
+
 // Condition Variable
+
+#if _WIN32_WINNT >= _WIN32_WINNT_VISTA
+
+int __libcpp_condvar_init(__libcpp_condvar_t *__cv)
+{
+  *__cv = _LIBCPP_CONDVAR_INITIALIZER;
+  return 0;
+}
+
 int __libcpp_condvar_signal(__libcpp_condvar_t *__cv)
 {
   WakeConditionVariable((PCONDITION_VARIABLE)__cv);
@@ -137,7 +216,184 @@ int __libcpp_condvar_destroy(__libcpp_condvar_t *__cv)
   return 0;
 }
 
+#else // _WIN32_WINNT >= _WIN32_WINNT_VISTA
+
+/*
+Note:
+  The implementation of condition variable is ported from Boost.Interprocess
+  See https://www.boost.org/doc/libs/1_53_0/boost/interprocess/sync/windows/condition.hpp
+*/
+
+static inline _LIBCPP_INLINE_VISIBILITY void
+__libcpp_condvar_do_signal(__libcpp_condvar_do_t *__cond,
+                           bool __broadcast)
+{
+  int nsignal = 0;
+
+  EnterCriticalSection(&__cond->mtx_unblock_lock);
+  if (__cond->nwaiters_to_unblock != 0) {
+    if (__cond->nwaiters_blocked == 0) {
+      LeaveCriticalSection(&__cond->mtx_unblock_lock);
+      return;
+    }
+    if (__broadcast) {
+      __cond->nwaiters_to_unblock += nsignal = __cond->nwaiters_blocked;
+      __cond->nwaiters_blocked = 0;
+    } else {
+      nsignal = 1;
+      __cond->nwaiters_to_unblock++;
+      __cond->nwaiters_blocked--;
+    }
+  } else if (__cond->nwaiters_blocked > __cond->nwaiters_gone) {
+    WaitForSingleObject(__cond->sem_block_lock, INFINITE);
+    if (__cond->nwaiters_gone != 0) {
+      __cond->nwaiters_blocked -= __cond->nwaiters_gone;
+      __cond->nwaiters_gone = 0;
+    }
+    if (__broadcast) {
+      nsignal = __cond->nwaiters_to_unblock = __cond->nwaiters_blocked;
+      __cond->nwaiters_blocked = 0;
+    } else {
+      nsignal = __cond->nwaiters_to_unblock = 1;
+      __cond->nwaiters_blocked--;
+    }
+  }
+  LeaveCriticalSection(&__cond->mtx_unblock_lock);
+
+  if (0 < nsignal)
+    ReleaseSemaphore(__cond->sem_block_queue, nsignal, nullptr);
+}
+
+static inline _LIBCPP_INLINE_VISIBILITY int
+__libcpp_condvar_do_wait(__libcpp_condvar_do_t *__cond,
+                         __libcpp_mutex_t *__m,
+                         __libcpp_timespec_t *__ts)
+{
+  using namespace _VSTD::chrono;
+
+  DWORD timeout_ms = INFINITE;
+  if (__ts) {
+    auto duration = seconds(__ts->tv_sec) + nanoseconds(__ts->tv_nsec);
+    auto abstime =
+        system_clock::time_point(duration_cast<system_clock::duration>(duration));
+    timeout_ms = duration_cast<milliseconds>(
+        abstime - system_clock::now()).count();
+  }
+
+  int nleft = 0;
+  int nnwaiters_gone = 0;
+  int timeout = 0;
+  DWORD w;
+
+  WaitForSingleObject(__cond->sem_block_lock, INFINITE);
+  __cond->nwaiters_blocked++;
+  ReleaseSemaphore(__cond->sem_block_lock, 1, nullptr);
+
+  __libcpp_mutex_unlock(__m);
+
+  w = WaitForSingleObject(__cond->sem_block_queue, timeout_ms);
+  timeout = (w == WAIT_TIMEOUT);
+
+  EnterCriticalSection(&__cond->mtx_unblock_lock);
+  if ((nleft = __cond->nwaiters_to_unblock) != 0) {
+    if (timeout) {
+      if (__cond->nwaiters_blocked != 0) {
+        __cond->nwaiters_blocked--;
+      } else {
+        __cond->nwaiters_gone++;
+      }
+    }
+    if (--__cond->nwaiters_to_unblock == 0) {
+      if (__cond->nwaiters_blocked != 0) {
+        ReleaseSemaphore(__cond->sem_block_lock, 1, nullptr);
+        nleft = 0;
+      }
+      else if ((nnwaiters_gone = __cond->nwaiters_gone) != 0) {
+        __cond->nwaiters_gone = 0;
+      }
+    }
+  } else if (++__cond->nwaiters_gone == INT_MAX / 2) {
+    WaitForSingleObject(__cond->sem_block_lock, INFINITE);
+    __cond->nwaiters_blocked -= __cond->nwaiters_gone;
+    ReleaseSemaphore(__cond->sem_block_lock, 1, nullptr);
+    __cond->nwaiters_gone = 0;
+  }
+  LeaveCriticalSection(&__cond->mtx_unblock_lock);
+
+  if (nleft == 1) {
+    while (nnwaiters_gone--)
+      WaitForSingleObject(__cond->sem_block_queue, INFINITE);
+    ReleaseSemaphore(__cond->sem_block_lock, 1, nullptr);
+  }
+
+  __libcpp_mutex_lock(__m);
+  return timeout ? /* busy */ ETIMEDOUT : 0;
+}
+
+int __libcpp_condvar_init(__libcpp_condvar_t *__cv)
+{
+  auto __cond = reinterpret_cast<__libcpp_condvar_do_t*>(__cv);
+  __cond->nwaiters_blocked = 0;
+  __cond->nwaiters_gone = 0;
+  __cond->nwaiters_to_unblock = 0;
+  __cond->reserved = 0;
+  __cond->sem_block_queue = CreateSemaphore(nullptr, 0, _LIBCPP_SEMAPHORE_MAX,
+                                            nullptr);
+  __cond->sem_block_lock = CreateSemaphore(nullptr, 1, 1, nullptr);
+  InitializeCriticalSection(&__cond->mtx_unblock_lock);
+  return 0;
+}
+
+int __libcpp_condvar_signal(__libcpp_condvar_t *__cv)
+{
+  auto __do_cv = reinterpret_cast<__libcpp_condvar_do_t*>(__cv);
+  __libcpp_condvar_do_signal(__do_cv, false);
+  return 0;
+}
+
+int __libcpp_condvar_broadcast(__libcpp_condvar_t *__cv)
+{
+  auto __do_cv = reinterpret_cast<__libcpp_condvar_do_t*>(__cv);
+  __libcpp_condvar_do_signal(__do_cv, true);
+  return 0;
+}
+
+int __libcpp_condvar_wait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m)
+{
+  auto __do_cv = reinterpret_cast<__libcpp_condvar_do_t*>(__cv);
+  return __libcpp_condvar_do_wait(__do_cv, __m, nullptr);
+}
+
+int __libcpp_condvar_timedwait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m,
+                               __libcpp_timespec_t *__ts)
+{
+  auto __do_cv = reinterpret_cast<__libcpp_condvar_do_t*>(__cv);
+  return __libcpp_condvar_do_wait(__do_cv, __m, __ts);
+}
+
+int __libcpp_condvar_destroy(__libcpp_condvar_t *__cv)
+{
+  auto __cond = reinterpret_cast<__libcpp_condvar_do_t*>(__cv);
+  CloseHandle(__cond->sem_block_queue);
+  CloseHandle(__cond->sem_block_lock);
+  DeleteCriticalSection(&__cond->mtx_unblock_lock);
+  return 0;
+}
+
+#endif // _WIN32_WINNT >= _WIN32_WINNT_VISTA
+
 // Execute Once
+int __libcpp_execute_once(__libcpp_exec_once_flag *__flag,
+                          void *arg,
+                          void (*__init_routine)(void));
+
+#if _WIN32_WINNT >= _WIN32_WINNT_VISTA
+
+struct __libcpp_init_once_execute_context {
+  void* arg;
+  void (*init_routine)(void*);
+};
+
 static inline _LIBCPP_INLINE_VISIBILITY BOOL CALLBACK
 __libcpp_init_once_execute_once_thunk(PINIT_ONCE __init_once, PVOID __parameter,
                                       PVOID *__context)
@@ -145,20 +401,85 @@ __libcpp_init_once_execute_once_thunk(PINIT_ONCE __init_once, PVOID __parameter,
   static_cast<void>(__init_once);
   static_cast<void>(__context);
 
-  void (*init_routine)(void) = reinterpret_cast<void (*)(void)>(__parameter);
-  init_routine();
+  auto __ctx = reinterpret_cast<__libcpp_init_once_execute_context*>(__parameter);
+  __ctx->init_routine(__ctx->arg);
+
   return TRUE;
 }
 
 int __libcpp_execute_once(__libcpp_exec_once_flag *__flag,
-                          void (*__init_routine)(void))
+                          void *arg,
+                          void (*init_routine)(void*))
 {
+  __libcpp_init_once_execute_context __ctx;
+  __ctx.arg = arg;
+  __ctx.init_routine = init_routine;
   if (!InitOnceExecuteOnce((PINIT_ONCE)__flag, __libcpp_init_once_execute_once_thunk,
-                           reinterpret_cast<void *>(__init_routine), NULL))
+                           &__ctx, NULL))
     return GetLastError();
   return 0;
 }
 
+#else // _WIN32_WINNT >= _WIN32_WINNT_VISTA
+
+int __libcpp_execute_once(__libcpp_exec_once_flag *__flag,
+                          void *arg,
+                          void (*__init_routine)(void*))
+{
+  /* This assumes that reading *once has acquire semantics. This should be true
+   * on x86 and x86-64, where we expect Windows to run. */
+#if !defined(_M_IX86) && !defined(_M_X64)
+#error "Windows once code may not work on other platforms." \
+       "You can use InitOnceBeginInitialize on >=Vista"
+#endif
+
+  volatile LONG* __once = reinterpret_cast<volatile LONG*>(__flag);
+
+  static_assert(sizeof(*__flag) >= sizeof(*__once),
+                "exec_once_flag must contains at least a LONG variable");
+
+  if (*__once == 1) {
+    return 0;
+  }
+
+  for (;;) {
+    switch (InterlockedCompareExchange(__once, 2, 0)) {
+      case 0:
+        /* The value was zero so we are the first thread to call once
+         * on it. */
+        __init_routine(arg);
+        /* Write one to indicate that initialisation is complete. */
+        InterlockedExchange(__once, 1);
+        return 0;
+
+      case 1:
+        /* Another thread completed initialisation between our fast-path check
+         * and |InterlockedCompareExchange|. */
+        return 0;
+
+      case 2:
+        /* Another thread is running the initialisation. Switch to it then try
+         * again. */
+        SwitchToThread();
+        break;
+
+      default:
+        abort();
+    }
+  }
+  return 0;
+}
+
+#endif // _WIN32_WINNT >= _WIN32_WINNT_VISTA
+
+int __libcpp_execute_once(__libcpp_exec_once_flag *__flag,
+                          void (*init_routine)())
+{
+  return __libcpp_execute_once(__flag, nullptr,
+                               reinterpret_cast<void (*)(void*)>(init_routine));
+}
+
+
 // Thread ID
 bool __libcpp_thread_id_equal(__libcpp_thread_id __lhs,
                               __libcpp_thread_id __rhs)
@@ -178,6 +499,8 @@ struct __libcpp_beginthreadex_thunk_data
   void *__arg;
 };
 
+#if _WIN32_WINNT >= _WIN32_WINNT_VISTA
+
 static inline _LIBCPP_INLINE_VISIBILITY unsigned WINAPI
 __libcpp_beginthreadex_thunk(void *__raw_data)
 {
@@ -189,10 +512,32 @@ __libcpp_beginthreadex_thunk(void *__raw_data)
   return static_cast<unsigned>(reinterpret_cast<uintptr_t>(__func(__arg)));
 }
 
+#else // _WIN32_WINNT >= _WIN32_WINNT_VISTA
+
+static inline _LIBCPP_INLINE_VISIBILITY void
+__libcpp_tls_tss_dor_invoke();
+
+static inline _LIBCPP_INLINE_VISIBILITY unsigned WINAPI
+__libcpp_beginthreadex_thunk(void *__raw_data)
+{
+  auto *__data =
+      static_cast<__libcpp_beginthreadex_thunk_data *>(__raw_data);
+  auto *__func = __data->__func;
+  void *__arg = __data->__arg;
+  delete __data;
+  int ret;
+  ret = static_cast<unsigned>(reinterpret_cast<uintptr_t>(__func(__arg)));
+  __libcpp_tls_tss_dor_invoke();
+  return ret;
+}
+
+#endif // _WIN32_WINNT >= _WIN32_WINNT_VISTA
+
 bool __libcpp_thread_isnull(const __libcpp_thread_t *__t) {
   return *__t == 0;
 }
 
+#if !defined(_LIBCPP_MSVCRT)
 int __libcpp_thread_create(__libcpp_thread_t *__t, void *(*__func)(void *),
                            void *__arg)
 {
@@ -209,15 +554,40 @@ int __libcpp_thread_create(__libcpp_thread_t *__t, void *(*__func)(void *),
   return GetLastError();
 }
 
-__libcpp_thread_id __libcpp_thread_get_current_id()
+#else
+
+int __libcpp_thread_create(__libcpp_thread_t *__t, __libcpp_thread_id* __t_id,
+                           void *(*__func)(void *), void *__arg)
 {
-  return GetCurrentThreadId();
+  auto *__data = new __libcpp_beginthreadex_thunk_data;
+  __data->__func = __func;
+  __data->__arg = __arg;
+
+  unsigned __id;
+
+  *__t = reinterpret_cast<HANDLE>(_beginthreadex(nullptr, 0,
+                                                 __libcpp_beginthreadex_thunk,
+                                                 __data, 0, &__id));
+
+  *__t_id = __id;
+
+  if (*__t)
+    return 0;
+  return GetLastError();
 }
+#endif
 
+#if !defined(_LIBCPP_MSVCRT)
 __libcpp_thread_id __libcpp_thread_get_id(const __libcpp_thread_t *__t)
 {
   return GetThreadId(*__t);
 }
+#endif
+
+__libcpp_thread_id __libcpp_thread_get_current_id()
+{
+  return GetCurrentThreadId();
+}
 
 int __libcpp_thread_join(__libcpp_thread_t *__t)
 {
@@ -249,6 +619,7 @@ void __libcpp_thread_sleep_for(const chrono::nanoseconds& __ns)
 }
 
 // Thread Local Storage
+#if _WIN32_WINNT >= _WIN32_WINNT_VISTA
 int __libcpp_tls_create(__libcpp_tls_key* __key,
                         void(_LIBCPP_TLS_DESTRUCTOR_CC* __at_exit)(void*))
 {
@@ -271,4 +642,76 @@ int __libcpp_tls_set(__libcpp_tls_key __key, void *__p)
   return 0;
 }
 
+#else // _WIN32_WINNT >= _WIN32_WINNT_VISTA
+
+// https://devblogs.microsoft.com/oldnewthing/20160613-00/?p=93655
+// see also TLS_MINIMUM_AVAILABLE
+#define EMULATED_THREADS_TSS_DTOR_SLOTNUM 1024
+
+typedef void (*_LIBCPP_TLS_DESTRUCTOR_CC __libcpp_tls_dtor_t)(void *);
+
+static struct __libcpp_tls_tss_dor_entry {
+  __libcpp_tls_key key;
+  __libcpp_tls_dtor_t dtor;
+} __libcpp_tls_tss_dor_tbl[EMULATED_THREADS_TSS_DTOR_SLOTNUM];
+
+static inline _LIBCPP_INLINE_VISIBILITY int
+__libcpp_tls_tss_dor_register(__libcpp_tls_key key,
+                              __libcpp_tls_dtor_t dtor)
+{
+  int i;
+  for (i = 0; i < EMULATED_THREADS_TSS_DTOR_SLOTNUM; i++) {
+    if (!__libcpp_tls_tss_dor_tbl[i].dtor)
+      break;
+  }
+  if (i == EMULATED_THREADS_TSS_DTOR_SLOTNUM)
+    return 1;
+  __libcpp_tls_tss_dor_tbl[i].key = key;
+  __libcpp_tls_tss_dor_tbl[i].dtor = dtor;
+  return 0;
+}
+
+static inline _LIBCPP_INLINE_VISIBILITY void
+__libcpp_tls_tss_dor_invoke()
+{
+  int i;
+  for (i = 0; i < EMULATED_THREADS_TSS_DTOR_SLOTNUM; i++) {
+    if (__libcpp_tls_tss_dor_tbl[i].dtor) {
+      void* val = __libcpp_tls_get(__libcpp_tls_tss_dor_tbl[i].key);
+      if (val)
+        (__libcpp_tls_tss_dor_tbl[i].dtor)(val);
+    }
+  }
+}
+
+int __libcpp_tls_create(__libcpp_tls_key* __key,
+                        void(_LIBCPP_TLS_DESTRUCTOR_CC* __at_exit)(void*))
+{
+  DWORD index = TlsAlloc();
+  if (index == TLS_OUT_OF_INDEXES)
+    return GetLastError();
+  if (__libcpp_tls_tss_dor_register(index, __at_exit)) {
+    TlsFree(index);
+    return ERROR_INVALID_BLOCK;
+  }
+  *__key = index;
+  return 0;
+}
+
+void *__libcpp_tls_get(__libcpp_tls_key __key)
+{
+  return TlsGetValue(__key);
+}
+
+int __libcpp_tls_set(__libcpp_tls_key __key, void *__p)
+{
+  if (!TlsSetValue(__key, __p))
+    return GetLastError();
+  return 0;
+}
+
+#endif // _WIN32_WINNT >= _WIN32_WINNT_VISTA
+
 _LIBCPP_END_NAMESPACE_STD
+
+#endif // _LIBCPP_MSVCRT
-- 
2.41.0.windows.2

