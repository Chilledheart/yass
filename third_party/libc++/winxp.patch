From 5a32ca743e0d60bb19c4462a8af28815e58e5028 Mon Sep 17 00:00:00 2001
From: Chilledheart <rwindz0@gmail.com>
Date: Mon, 28 Feb 2022 17:19:34 +0800
Subject: [PATCH] win32: add support for xp

stays closer with msvc stl's non-standard mutex/thread/condtion_variable
---
 include/__mutex_base                  |   8 +
 include/__threading_support           |  46 +++
 include/mutex                         |  45 +++
 include/thread                        |  45 +++
 src/condition_variable.cpp            |   7 +
 src/condition_variable_destructor.cpp |   6 +-
 src/memory.cpp                        |   4 +
 src/mutex.cpp                         |   7 +
 src/mutex_destructor.cpp              |   9 +-
 src/random_shuffle.cpp                |   3 +
 src/support/win32/thread_win32.cpp    | 467 +++++++++++++++++++++++++-
 11 files changed, 635 insertions(+), 12 deletions(-)

diff --git a/include/__mutex_base b/include/__mutex_base
index 05a08a558..16502def0 100644
--- a/include/__mutex_base
+++ b/include/__mutex_base
@@ -34,8 +34,12 @@ class _LIBCPP_TYPE_VIS _LIBCPP_THREAD_SAFETY_ANNOTATION(capability("mutex")) mut
     __libcpp_mutex_t __m_ = _LIBCPP_MUTEX_INITIALIZER;
 
 public:
+#if !defined(_LIBCPP_MSVCRT)
     _LIBCPP_INLINE_VISIBILITY
     _LIBCPP_CONSTEXPR mutex() = default;
+#else
+    mutex() _NOEXCEPT;
+#endif
 
     mutex(const mutex&) = delete;
     mutex& operator=(const mutex&) = delete;
@@ -274,8 +278,12 @@ class _LIBCPP_TYPE_VIS condition_variable
 {
     __libcpp_condvar_t __cv_ = _LIBCPP_CONDVAR_INITIALIZER;
 public:
+#if !defined(_LIBCPP_MSVCRT)
     _LIBCPP_INLINE_VISIBILITY
     _LIBCPP_CONSTEXPR condition_variable() _NOEXCEPT = default;
+#else
+    condition_variable() _NOEXCEPT;
+#endif
 
 #ifdef _LIBCPP_HAS_TRIVIAL_CONDVAR_DESTRUCTION
     ~condition_variable() = default;
diff --git a/include/__threading_support b/include/__threading_support
index 430ec5419..11cdb305a 100644
--- a/include/__threading_support
+++ b/include/__threading_support
@@ -133,8 +133,19 @@ typedef tss_t __libcpp_tls_key;
 #define _LIBCPP_TLS_DESTRUCTOR_CC
 #elif !defined(_LIBCPP_HAS_THREAD_API_EXTERNAL)
 // Mutex
+#if !defined(_LIBCPP_MSVCRT) || (defined(_LIBCPP_MSVCRT) && (_WIN32_WINNT >= 0x0600))
 typedef void* __libcpp_mutex_t;
 #define _LIBCPP_MUTEX_INITIALIZER 0
+#else
+#if defined(_M_IX86)|| defined(_M_ARM)
+typedef void* __libcpp_mutex_t[6];
+#elif defined(_M_AMD64) || defined(_M_ARM64)
+typedef void* __libcpp_mutex_t[5];
+#else
+# error Unsupported architecture
+#endif
+#define _LIBCPP_MUTEX_INITIALIZER {}
+#endif
 
 #if defined(_M_IX86) || defined(__i386__) || defined(_M_ARM) || defined(__arm__)
 typedef void* __libcpp_recursive_mutex_t[6];
@@ -145,8 +156,19 @@ typedef void* __libcpp_recursive_mutex_t[5];
 #endif
 
 // Condition Variable
+#if !defined(_LIBCPP_MSVCRT) || (defined(_LIBCPP_MSVCRT) && (_WIN32_WINNT >= 0x0600))
 typedef void* __libcpp_condvar_t;
 #define _LIBCPP_CONDVAR_INITIALIZER 0
+#else
+#if defined(_M_IX86)|| defined(_M_ARM)
+typedef void* __libcpp_condvar_t[4+2+6];
+#elif defined(_M_AMD64) || defined(_M_ARM64)
+typedef void* __libcpp_condvar_t[2+2+5];
+#else
+# error Unsupported architecture
+#endif
+#define _LIBCPP_CONDVAR_INITIALIZER {}
+#endif
 
 // Semaphore
 typedef void* __libcpp_semaphore_t;
@@ -189,6 +211,11 @@ int __libcpp_recursive_mutex_unlock(__libcpp_recursive_mutex_t *__m);
 _LIBCPP_THREAD_ABI_VISIBILITY
 int __libcpp_recursive_mutex_destroy(__libcpp_recursive_mutex_t *__m);
 
+#if defined(_LIBCPP_MSVCRT)
+_LIBCPP_THREAD_ABI_VISIBILITY _LIBCPP_NO_THREAD_SAFETY_ANALYSIS
+int __libcpp_mutex_init(__libcpp_mutex_t *__m);
+#endif
+
 _LIBCPP_THREAD_ABI_VISIBILITY _LIBCPP_NO_THREAD_SAFETY_ANALYSIS
 int __libcpp_mutex_lock(__libcpp_mutex_t *__m);
 
@@ -202,6 +229,11 @@ _LIBCPP_THREAD_ABI_VISIBILITY
 int __libcpp_mutex_destroy(__libcpp_mutex_t *__m);
 
 // Condition variable
+#if defined(_LIBCPP_MSVCRT)
+_LIBCPP_THREAD_ABI_VISIBILITY
+int __libcpp_condvar_init(__libcpp_condvar_t* __cv);
+#endif
+
 _LIBCPP_THREAD_ABI_VISIBILITY
 int __libcpp_condvar_signal(__libcpp_condvar_t* __cv);
 
@@ -239,6 +271,12 @@ bool __libcpp_semaphore_wait_timed(__libcpp_semaphore_t* __sem, chrono::nanoseco
 #endif // _LIBCPP_NO_NATIVE_SEMAPHORES
 
 // Execute once
+#if defined(_LIBCPP_MSVCRT)
+_LIBCPP_THREAD_ABI_VISIBILITY
+int __libcpp_execute_once(__libcpp_exec_once_flag *flag,
+                          void *arg,
+                          void (*init_routine)(void*));
+#endif
 _LIBCPP_THREAD_ABI_VISIBILITY
 int __libcpp_execute_once(__libcpp_exec_once_flag *flag,
                           void (*init_routine)());
@@ -254,15 +292,23 @@ bool __libcpp_thread_id_less(__libcpp_thread_id t1, __libcpp_thread_id t2);
 _LIBCPP_THREAD_ABI_VISIBILITY
 bool __libcpp_thread_isnull(const __libcpp_thread_t *__t);
 
+#if !defined(_LIBCPP_MSVCRT)
 _LIBCPP_THREAD_ABI_VISIBILITY
 int __libcpp_thread_create(__libcpp_thread_t *__t, void *(*__func)(void *),
                            void *__arg);
+#else
+_LIBCPP_THREAD_ABI_VISIBILITY
+int __libcpp_thread_create(__libcpp_thread_t *__t, __libcpp_thread_id* __t_id,
+                           void *(*__func)(void *), void *__arg);
+#endif
 
 _LIBCPP_THREAD_ABI_VISIBILITY
 __libcpp_thread_id __libcpp_thread_get_current_id();
 
+#if !defined(_LIBCPP_MSVCRT)
 _LIBCPP_THREAD_ABI_VISIBILITY
 __libcpp_thread_id __libcpp_thread_get_id(const __libcpp_thread_t *__t);
+#endif
 
 _LIBCPP_THREAD_ABI_VISIBILITY
 int __libcpp_thread_join(__libcpp_thread_t *__t);
diff --git a/include/mutex b/include/mutex
index babb2b429..c64e889d4 100644
--- a/include/mutex
+++ b/include/mutex
@@ -574,7 +574,11 @@ struct _LIBCPP_TEMPLATE_VIS once_flag
 {
     _LIBCPP_INLINE_VISIBILITY
     _LIBCPP_CONSTEXPR
+#if defined(_LIBCPP_MSVCRT)
+        once_flag() _NOEXCEPT : __state_(_LIBCPP_EXEC_ONCE_INITIALIZER) {}
+#else
         once_flag() _NOEXCEPT : __state_(0) {}
+#endif
 
 #if defined(_LIBCPP_ABI_MICROSOFT)
    typedef uintptr_t _State_type;
@@ -657,6 +661,45 @@ __call_once_proxy(void* __vp)
     (*__p)();
 }
 
+#ifdef _LIBCPP_MSVCRT
+
+#ifndef _LIBCPP_CXX03_LANG
+
+template<class _Callable, class... _Args>
+inline _LIBCPP_INLINE_VISIBILITY
+void
+call_once(once_flag& __flag, _Callable&& __func, _Args&&... __args)
+{
+  typedef tuple<_Callable&&, _Args&&...> _Gp;
+  _Gp __f(_VSTD::forward<_Callable>(__func), _VSTD::forward<_Args>(__args)...);
+  __call_once_param<_Gp> __p(__f);
+  __libcpp_execute_once(reinterpret_cast<__libcpp_exec_once_flag*>(&__flag.__state_), &__p, &__call_once_proxy<_Gp>);
+}
+
+#else  // _LIBCPP_CXX03_LANG
+
+template<class _Callable>
+inline _LIBCPP_INLINE_VISIBILITY
+void
+call_once(once_flag& __flag, _Callable& __func)
+{
+   __call_once_param<_Callable> __p(__func);
+   __libcpp_execute_once(reinterpret_cast<__libcpp_exec_once_flag*>(&__flag.__state_), &__p, &__call_once_proxy<_Callable>);
+}
+
+template<class _Callable>
+inline _LIBCPP_INLINE_VISIBILITY
+void
+call_once(once_flag& __flag, const _Callable& __func)
+{
+  __call_once_param<const _Callable> __p(__func);
+  ___libcpp_execute_once(reinterpret_cast<__libcpp_exec_once_flag*>(&__flag.__state_), &__p, &__call_once_proxy<const _Callable>);
+}
+
+#endif // _LIBCPP_CXX03_LANG
+
+#else // _LIBCPP_MSVCRT
+
 _LIBCPP_FUNC_VIS void __call_once(volatile once_flag::_State_type&, void*,
                                   void (*)(void*));
 
@@ -704,6 +747,8 @@ call_once(once_flag& __flag, const _Callable& __func)
 
 #endif // _LIBCPP_CXX03_LANG
 
+#endif // _LIBCPP_MSVCRT
+
 _LIBCPP_END_NAMESPACE_STD
 
 _LIBCPP_POP_MACROS
diff --git a/include/thread b/include/thread
index 89a9c61e4..68371b9da 100644
--- a/include/thread
+++ b/include/thread
@@ -216,6 +216,9 @@ operator<<(basic_ostream<_CharT, _Traits>& __os, __thread_id __id)
 class _LIBCPP_TYPE_VIS thread
 {
     __libcpp_thread_t __t_;
+#if defined(_LIBCPP_MSVCRT)
+    __libcpp_thread_id __t_id_;
+#endif
 
     thread(const thread&);
     thread& operator=(const thread&);
@@ -241,29 +244,63 @@ public:
 #endif
     ~thread();
 
+#if !defined(_LIBCPP_MSVCRT)
     _LIBCPP_INLINE_VISIBILITY
     thread(thread&& __t) _NOEXCEPT : __t_(__t.__t_) {
         __t.__t_ = _LIBCPP_NULL_THREAD;
     }
+#else
+    _LIBCPP_INLINE_VISIBILITY
+    thread(thread&& __t) _NOEXCEPT : __t_(__t.__t_), __t_id_(__t.__t_id_) {
+        __t.__t_ = _LIBCPP_NULL_THREAD;
+        __t.__t_id_ = 0;
+    }
+#endif
 
+#if !defined(_LIBCPP_MSVCRT)
+    _LIBCPP_INLINE_VISIBILITY
+    thread& operator=(thread&& __t) _NOEXCEPT {
+        if (!__libcpp_thread_isnull(&__t_))
+            terminate();
+        __t_ = __t.__t_;
+        __t.__t_ = _LIBCPP_NULL_THREAD;
+        return *this;
+    }
+#else
     _LIBCPP_INLINE_VISIBILITY
     thread& operator=(thread&& __t) _NOEXCEPT {
         if (!__libcpp_thread_isnull(&__t_))
             terminate();
         __t_ = __t.__t_;
+        __t_id_ = __t.__t_id_;
         __t.__t_ = _LIBCPP_NULL_THREAD;
+        __t.__t_id_ = 0;
         return *this;
     }
+#endif
 
+#if !defined(_LIBCPP_MSVCRT)
     _LIBCPP_INLINE_VISIBILITY
     void swap(thread& __t) _NOEXCEPT {_VSTD::swap(__t_, __t.__t_);}
+#else
+    _LIBCPP_INLINE_VISIBILITY
+    void swap(thread& __t) _NOEXCEPT {
+      _VSTD::swap(__t_, __t.__t_);
+      _VSTD::swap(__t_id_, __t.__t_id_);
+    }
+#endif
 
     _LIBCPP_INLINE_VISIBILITY
     bool joinable() const _NOEXCEPT {return !__libcpp_thread_isnull(&__t_);}
     void join();
     void detach();
+#if !defined(_LIBCPP_MSVCRT)
     _LIBCPP_INLINE_VISIBILITY
     id get_id() const _NOEXCEPT {return __libcpp_thread_get_id(&__t_);}
+#else
+    _LIBCPP_INLINE_VISIBILITY
+    id get_id() const _NOEXCEPT {return __t_id_; }
+#endif
     _LIBCPP_INLINE_VISIBILITY
     native_handle_type native_handle() _NOEXCEPT {return __t_;}
 
@@ -304,7 +341,11 @@ thread::thread(_Fp&& __f, _Args&&... __args)
             new _Gp(_VSTD::move(__tsp),
                     _VSTD::__decay_copy(_VSTD::forward<_Fp>(__f)),
                     _VSTD::__decay_copy(_VSTD::forward<_Args>(__args))...));
+#if !defined(_LIBCPP_MSVCRT)
     int __ec = _VSTD::__libcpp_thread_create(&__t_, &__thread_proxy<_Gp>, __p.get());
+#else
+    int __ec = _VSTD::__libcpp_thread_create(&__t_, &__t_id_, &__thread_proxy<_Gp>, __p.get());
+#endif
     if (__ec == 0)
         __p.release();
     else
@@ -339,7 +380,11 @@ thread::thread(_Fp __f)
     typedef __thread_invoke_pair<_Fp> _InvokePair;
     typedef unique_ptr<_InvokePair> _PairPtr;
     _PairPtr __pp(new _InvokePair(__f));
+#if defined(_LIBCPP_MSVCRT)
     int __ec = _VSTD::__libcpp_thread_create(&__t_, &__thread_proxy_cxx03<_InvokePair>, __pp.get());
+#else
+    int __ec = _VSTD::__libcpp_thread_create(&__t_, &__thread_proxy_cxx03<_InvokePair>, __pp.get());
+#endif
     if (__ec == 0)
         __pp.release();
     else
diff --git a/src/condition_variable.cpp b/src/condition_variable.cpp
index 1e29083e6..720d28ccc 100644
--- a/src/condition_variable.cpp
+++ b/src/condition_variable.cpp
@@ -21,6 +21,13 @@
 
 _LIBCPP_BEGIN_NAMESPACE_STD
 
+#if defined(_LIBCPP_MSVCRT)
+condition_variable::condition_variable() _NOEXCEPT
+{
+    __libcpp_condvar_init(&__cv_);
+}
+#endif
+
 // ~condition_variable is defined elsewhere.
 
 void
diff --git a/src/condition_variable_destructor.cpp b/src/condition_variable_destructor.cpp
index 44fa240ba..961f3a970 100644
--- a/src/condition_variable_destructor.cpp
+++ b/src/condition_variable_destructor.cpp
@@ -28,8 +28,12 @@ class _LIBCPP_TYPE_VIS condition_variable
 {
     __libcpp_condvar_t __cv_ = _LIBCPP_CONDVAR_INITIALIZER;
 public:
+#if !defined(_LIBCPP_MSVCRT)
     _LIBCPP_INLINE_VISIBILITY
-    constexpr condition_variable() noexcept = default;
+    _LIBCPP_CONSTEXPR condition_variable() _NOEXCEPT = default;
+#else
+    condition_variable() _NOEXCEPT;
+#endif
 
     ~condition_variable();
 
diff --git a/src/memory.cpp b/src/memory.cpp
index 9bd27df26..720565051 100644
--- a/src/memory.cpp
+++ b/src/memory.cpp
@@ -144,6 +144,10 @@ _LIBCPP_SAFE_STATIC static __libcpp_mutex_t mut_back[__sp_mut_count] =
 _LIBCPP_CONSTEXPR __sp_mut::__sp_mut(void* p) noexcept
    : __lx(p)
 {
+    auto m = static_cast<__libcpp_mutex_t*>(__lx);
+#if defined(_LIBCPP_MSVCRT)
+    __libcpp_mutex_init(m);
+#endif
 }
 
 void
diff --git a/src/mutex.cpp b/src/mutex.cpp
index 36362e34f..0bd944e4f 100644
--- a/src/mutex.cpp
+++ b/src/mutex.cpp
@@ -25,6 +25,13 @@ const defer_lock_t  defer_lock{};
 const try_to_lock_t try_to_lock{};
 const adopt_lock_t  adopt_lock{};
 
+#if defined(_LIBCPP_MSVCRT)
+mutex::mutex() _NOEXCEPT
+{
+    __libcpp_mutex_init(&__m_);
+}
+#endif
+
 // ~mutex is defined elsewhere
 
 void
diff --git a/src/mutex_destructor.cpp b/src/mutex_destructor.cpp
index 07197c3fb..e0768e332 100644
--- a/src/mutex_destructor.cpp
+++ b/src/mutex_destructor.cpp
@@ -33,8 +33,13 @@ class _LIBCPP_TYPE_VIS mutex
     __libcpp_mutex_t __m_ = _LIBCPP_MUTEX_INITIALIZER;
 
 public:
-    _LIBCPP_ALWAYS_INLINE _LIBCPP_INLINE_VISIBILITY
-    constexpr mutex() = default;
+#if !defined(_LIBCPP_MSVCRT)
+    _LIBCPP_INLINE_VISIBILITY
+    _LIBCPP_CONSTEXPR mutex() = default;
+#else
+    mutex() _NOEXCEPT;
+#endif
+
     mutex(const mutex&) = delete;
     mutex& operator=(const mutex&) = delete;
     ~mutex() noexcept;
diff --git a/src/random_shuffle.cpp b/src/random_shuffle.cpp
index be2c47fa0..48236eaeb 100644
--- a/src/random_shuffle.cpp
+++ b/src/random_shuffle.cpp
@@ -25,6 +25,9 @@ unsigned __rs_default::__c_ = 0;
 __rs_default::__rs_default()
 {
 #ifndef _LIBCPP_HAS_NO_THREADS
+#if defined(_LIBCPP_MSVCRT)
+    __libcpp_mutex_init(&__rs_mut);
+#endif
     __libcpp_mutex_lock(&__rs_mut);
 #endif
     __c_ = 1;
diff --git a/src/support/win32/thread_win32.cpp b/src/support/win32/thread_win32.cpp
index 63c5aa653..18589af79 100644
--- a/src/support/win32/thread_win32.cpp
+++ b/src/support/win32/thread_win32.cpp
@@ -12,23 +12,49 @@
 #define WIN32_LEAN_AND_MEAN
 #include <windows.h>
 #include <process.h>
+
+#if _WIN32_WINNT >= _WIN32_WINNT_VISTA
 #include <fibersapi.h>
+#endif
 
 _LIBCPP_BEGIN_NAMESPACE_STD
 
+#if _WIN32_WINNT >= _WIN32_WINNT_VISTA
 static_assert(sizeof(__libcpp_mutex_t) == sizeof(SRWLOCK), "");
 static_assert(alignof(__libcpp_mutex_t) == alignof(SRWLOCK), "");
-
+#else
+static_assert(sizeof(__libcpp_mutex_t) == sizeof(CRITICAL_SECTION), "");
+static_assert(alignof(__libcpp_mutex_t) == alignof(CRITICAL_SECTION), "");
+#endif
 static_assert(sizeof(__libcpp_recursive_mutex_t) == sizeof(CRITICAL_SECTION),
               "");
 static_assert(alignof(__libcpp_recursive_mutex_t) == alignof(CRITICAL_SECTION),
               "");
 
+#if _WIN32_WINNT >= _WIN32_WINNT_VISTA
 static_assert(sizeof(__libcpp_condvar_t) == sizeof(CONDITION_VARIABLE), "");
 static_assert(alignof(__libcpp_condvar_t) == alignof(CONDITION_VARIABLE), "");
-
+#else
+typedef struct {
+  int nwaiters_blocked;
+  int nwaiters_gone;
+  int nwaiters_to_unblock;
+  int reserved;
+  HANDLE sem_block_queue;
+  HANDLE sem_block_lock;
+  CRITICAL_SECTION mtx_unblock_lock;
+} __libcpp_condvar_do_t;
+static_assert(sizeof(__libcpp_condvar_t) == sizeof(__libcpp_condvar_do_t), "");
+static_assert(alignof(__libcpp_condvar_t) == alignof(__libcpp_condvar_do_t), "");
+#endif
+
+#if _WIN32_WINNT >= _WIN32_WINNT_VISTA
 static_assert(sizeof(__libcpp_exec_once_flag) == sizeof(INIT_ONCE), "");
 static_assert(alignof(__libcpp_exec_once_flag) == alignof(INIT_ONCE), "");
+#else
+static_assert(sizeof(__libcpp_exec_once_flag) >= sizeof(LONG), "");
+static_assert(alignof(__libcpp_exec_once_flag) >= alignof(LONG), "");
+#endif
 
 static_assert(sizeof(__libcpp_thread_id) == sizeof(DWORD), "");
 static_assert(alignof(__libcpp_thread_id) == alignof(DWORD), "");
@@ -72,6 +98,14 @@ int __libcpp_recursive_mutex_destroy(__libcpp_recursive_mutex_t *__m)
   return 0;
 }
 
+#if _WIN32_WINNT >= _WIN32_WINNT_WIN7
+
+int __libcpp_mutex_init(__libcpp_mutex_t *__m)
+{
+  *__m = _LIBCPP_MUTEX_INITIALIZER;
+  return 0;
+}
+
 int __libcpp_mutex_lock(__libcpp_mutex_t *__m)
 {
   AcquireSRWLockExclusive((PSRWLOCK)__m);
@@ -95,7 +129,49 @@ int __libcpp_mutex_destroy(__libcpp_mutex_t *__m)
   return 0;
 }
 
+#else // _WIN32_WINNT >= _WIN32_WINNT_WIN7
+
+int __libcpp_mutex_init(__libcpp_mutex_t *__m)
+{
+  InitializeCriticalSection((LPCRITICAL_SECTION)__m);
+  return 0;
+}
+
+int __libcpp_mutex_lock(__libcpp_mutex_t *__m)
+{
+  EnterCriticalSection((LPCRITICAL_SECTION)__m);
+  return 0;
+}
+
+bool __libcpp_mutex_trylock(__libcpp_mutex_t *__m)
+{
+  return TryEnterCriticalSection((LPCRITICAL_SECTION)__m) != 0;
+}
+
+int __libcpp_mutex_unlock(__libcpp_mutex_t *__m)
+{
+  LeaveCriticalSection((LPCRITICAL_SECTION)__m);
+  return 0;
+}
+
+int __libcpp_mutex_destroy(__libcpp_mutex_t *__m)
+{
+  DeleteCriticalSection((LPCRITICAL_SECTION)__m);
+  return 0;
+}
+
+#endif // _WIN32_WINNT >= _WIN32_WINNT_WIN7
+
 // Condition Variable
+
+#if _WIN32_WINNT >= _WIN32_WINNT_VISTA
+
+int __libcpp_condvar_init(__libcpp_condvar_t *__cv)
+{
+  *__cv = _LIBCPP_CONDVAR_INITIALIZER;
+  return 0;
+}
+
 int __libcpp_condvar_signal(__libcpp_condvar_t *__cv)
 {
   WakeConditionVariable((PCONDITION_VARIABLE)__cv);
@@ -141,7 +217,184 @@ int __libcpp_condvar_destroy(__libcpp_condvar_t *__cv)
   return 0;
 }
 
+#else // _WIN32_WINNT >= _WIN32_WINNT_VISTA
+
+/*
+Note:
+  The implementation of condition variable is ported from Boost.Interprocess
+  See https://www.boost.org/doc/libs/1_53_0/boost/interprocess/sync/windows/condition.hpp
+*/
+
+static inline _LIBCPP_INLINE_VISIBILITY void
+__libcpp_condvar_do_signal(__libcpp_condvar_do_t *__cond,
+                           bool __broadcast)
+{
+  int nsignal = 0;
+
+  EnterCriticalSection(&__cond->mtx_unblock_lock);
+  if (__cond->nwaiters_to_unblock != 0) {
+    if (__cond->nwaiters_blocked == 0) {
+      LeaveCriticalSection(&__cond->mtx_unblock_lock);
+      return;
+    }
+    if (__broadcast) {
+      __cond->nwaiters_to_unblock += nsignal = __cond->nwaiters_blocked;
+      __cond->nwaiters_blocked = 0;
+    } else {
+      nsignal = 1;
+      __cond->nwaiters_to_unblock++;
+      __cond->nwaiters_blocked--;
+    }
+  } else if (__cond->nwaiters_blocked > __cond->nwaiters_gone) {
+    WaitForSingleObject(__cond->sem_block_lock, INFINITE);
+    if (__cond->nwaiters_gone != 0) {
+      __cond->nwaiters_blocked -= __cond->nwaiters_gone;
+      __cond->nwaiters_gone = 0;
+    }
+    if (__broadcast) {
+      nsignal = __cond->nwaiters_to_unblock = __cond->nwaiters_blocked;
+      __cond->nwaiters_blocked = 0;
+    } else {
+      nsignal = __cond->nwaiters_to_unblock = 1;
+      __cond->nwaiters_blocked--;
+    }
+  }
+  LeaveCriticalSection(&__cond->mtx_unblock_lock);
+
+  if (0 < nsignal)
+    ReleaseSemaphore(__cond->sem_block_queue, nsignal, nullptr);
+}
+
+static inline _LIBCPP_INLINE_VISIBILITY int
+__libcpp_condvar_do_wait(__libcpp_condvar_do_t *__cond,
+                         __libcpp_mutex_t *__m,
+                         __libcpp_timespec_t *__ts)
+{
+  using namespace _VSTD::chrono;
+
+  DWORD timeout_ms = INFINITE;
+  if (__ts) {
+    auto duration = seconds(__ts->tv_sec) + nanoseconds(__ts->tv_nsec);
+    auto abstime =
+        system_clock::time_point(duration_cast<system_clock::duration>(duration));
+    timeout_ms = duration_cast<milliseconds>(
+        abstime - system_clock::now()).count();
+  }
+
+  int nleft = 0;
+  int nnwaiters_gone = 0;
+  int timeout = 0;
+  DWORD w;
+
+  WaitForSingleObject(__cond->sem_block_lock, INFINITE);
+  __cond->nwaiters_blocked++;
+  ReleaseSemaphore(__cond->sem_block_lock, 1, nullptr);
+
+  __libcpp_mutex_unlock(__m);
+
+  w = WaitForSingleObject(__cond->sem_block_queue, timeout_ms);
+  timeout = (w == WAIT_TIMEOUT);
+
+  EnterCriticalSection(&__cond->mtx_unblock_lock);
+  if ((nleft = __cond->nwaiters_to_unblock) != 0) {
+    if (timeout) {
+      if (__cond->nwaiters_blocked != 0) {
+        __cond->nwaiters_blocked--;
+      } else {
+        __cond->nwaiters_gone++;
+      }
+    }
+    if (--__cond->nwaiters_to_unblock == 0) {
+      if (__cond->nwaiters_blocked != 0) {
+        ReleaseSemaphore(__cond->sem_block_lock, 1, nullptr);
+        nleft = 0;
+      }
+      else if ((nnwaiters_gone = __cond->nwaiters_gone) != 0) {
+        __cond->nwaiters_gone = 0;
+      }
+    }
+  } else if (++__cond->nwaiters_gone == INT_MAX / 2) {
+    WaitForSingleObject(__cond->sem_block_lock, INFINITE);
+    __cond->nwaiters_blocked -= __cond->nwaiters_gone;
+    ReleaseSemaphore(__cond->sem_block_lock, 1, nullptr);
+    __cond->nwaiters_gone = 0;
+  }
+  LeaveCriticalSection(&__cond->mtx_unblock_lock);
+
+  if (nleft == 1) {
+    while (nnwaiters_gone--)
+      WaitForSingleObject(__cond->sem_block_queue, INFINITE);
+    ReleaseSemaphore(__cond->sem_block_lock, 1, nullptr);
+  }
+
+  __libcpp_mutex_lock(__m);
+  return timeout ? /* busy */ ETIMEDOUT : 0;
+}
+
+int __libcpp_condvar_init(__libcpp_condvar_t *__cv)
+{
+  auto __cond = reinterpret_cast<__libcpp_condvar_do_t*>(__cv);
+  __cond->nwaiters_blocked = 0;
+  __cond->nwaiters_gone = 0;
+  __cond->nwaiters_to_unblock = 0;
+  __cond->reserved = 0;
+  __cond->sem_block_queue = CreateSemaphore(nullptr, 0, _LIBCPP_SEMAPHORE_MAX,
+                                      nullptr);
+  __cond->sem_block_lock = CreateSemaphore(nullptr, 1, 1, nullptr);
+  InitializeCriticalSection(&__cond->mtx_unblock_lock);
+  return 0;
+}
+
+int __libcpp_condvar_signal(__libcpp_condvar_t *__cv)
+{
+  auto __do_cv = reinterpret_cast<__libcpp_condvar_do_t*>(__cv);
+  __libcpp_condvar_do_signal(__do_cv, false);
+  return 0;
+}
+
+int __libcpp_condvar_broadcast(__libcpp_condvar_t *__cv)
+{
+  auto __do_cv = reinterpret_cast<__libcpp_condvar_do_t*>(__cv);
+  __libcpp_condvar_do_signal(__do_cv, true);
+  return 0;
+}
+
+int __libcpp_condvar_wait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m)
+{
+  auto __do_cv = reinterpret_cast<__libcpp_condvar_do_t*>(__cv);
+  return __libcpp_condvar_do_wait(__do_cv, __m, nullptr);
+}
+
+int __libcpp_condvar_timedwait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m,
+                               __libcpp_timespec_t *__ts)
+{
+  auto __do_cv = reinterpret_cast<__libcpp_condvar_do_t*>(__cv);
+  return __libcpp_condvar_do_wait(__do_cv, __m, __ts);
+}
+
+int __libcpp_condvar_destroy(__libcpp_condvar_t *__cv)
+{
+  auto __cond = reinterpret_cast<__libcpp_condvar_do_t*>(__cv);
+  CloseHandle(__cond->sem_block_queue);
+  CloseHandle(__cond->sem_block_lock);
+  DeleteCriticalSection(&__cond->mtx_unblock_lock);
+  return 0;
+}
+
+#endif // _WIN32_WINNT >= _WIN32_WINNT_VISTA
+
 // Execute Once
+int __libcpp_execute_once(__libcpp_exec_once_flag *__flag,
+                          void *arg,
+                          void (*__init_routine)(void));
+
+#if _WIN32_WINNT >= _WIN32_WINNT_VISTA
+
+struct __libcpp_init_once_execute_context {
+  void* arg;
+  void (*init_routine)(void*);
+};
+
 static inline _LIBCPP_INLINE_VISIBILITY BOOL CALLBACK
 __libcpp_init_once_execute_once_thunk(PINIT_ONCE __init_once, PVOID __parameter,
                                       PVOID *__context)
@@ -149,20 +402,85 @@ __libcpp_init_once_execute_once_thunk(PINIT_ONCE __init_once, PVOID __parameter,
   static_cast<void>(__init_once);
   static_cast<void>(__context);
 
-  void (*init_routine)(void) = reinterpret_cast<void (*)(void)>(__parameter);
-  init_routine();
+  auto __ctx = reinterpret_cast<__libcpp_init_once_execute_context*>(__parameter);
+  __ctx->init_routine(__ctx->arg);
+
   return TRUE;
 }
 
 int __libcpp_execute_once(__libcpp_exec_once_flag *__flag,
-                          void (*__init_routine)(void))
+                          void *arg,
+                          void (*init_routine)(void*))
 {
+  __libcpp_init_once_execute_context __ctx;
+  __ctx.arg = arg;
+  __ctx.init_routine = init_routine;
   if (!InitOnceExecuteOnce((PINIT_ONCE)__flag, __libcpp_init_once_execute_once_thunk,
-                           reinterpret_cast<void *>(__init_routine), NULL))
+                           &__ctx, NULL))
     return GetLastError();
   return 0;
 }
 
+#else // _WIN32_WINNT >= _WIN32_WINNT_VISTA
+
+int __libcpp_execute_once(__libcpp_exec_once_flag *__flag,
+                          void *arg,
+                          void (*__init_routine)(void*))
+{
+  /* This assumes that reading *once has acquire semantics. This should be true
+   * on x86 and x86-64, where we expect Windows to run. */
+#if !defined(_M_IX86) && !defined(_M_X64)
+#error "Windows once code may not work on other platforms." \
+       "You can use InitOnceBeginInitialize on >=Vista"
+#endif
+
+  volatile LONG* __once = reinterpret_cast<volatile LONG*>(__flag);
+
+  static_assert(sizeof(*__flag) >= sizeof(*__once),
+                "exec_once_flag must contains at least a LONG variable");
+
+  if (*__once == 1) {
+    return 0;
+  }
+
+  for (;;) {
+    switch (InterlockedCompareExchange(__once, 2, 0)) {
+      case 0:
+        /* The value was zero so we are the first thread to call once
+         * on it. */
+        __init_routine(arg);
+        /* Write one to indicate that initialisation is complete. */
+        InterlockedExchange(__once, 1);
+        return 0;
+
+      case 1:
+        /* Another thread completed initialisation between our fast-path check
+         * and |InterlockedCompareExchange|. */
+        return 0;
+
+      case 2:
+        /* Another thread is running the initialisation. Switch to it then try
+         * again. */
+        SwitchToThread();
+        break;
+
+      default:
+        abort();
+    }
+  }
+  return 0;
+}
+
+#endif // _WIN32_WINNT >= _WIN32_WINNT_VISTA
+
+int __libcpp_execute_once(__libcpp_exec_once_flag *__flag,
+                          void (*init_routine)())
+{
+  return __libcpp_execute_once(__flag, nullptr,
+                               reinterpret_cast<void (*)(void*)>(init_routine));
+}
+
+
 // Thread ID
 bool __libcpp_thread_id_equal(__libcpp_thread_id __lhs,
                               __libcpp_thread_id __rhs)
@@ -182,6 +500,8 @@ struct __libcpp_beginthreadex_thunk_data
   void *__arg;
 };
 
+#if _WIN32_WINNT >= _WIN32_WINNT_VISTA
+
 static inline _LIBCPP_INLINE_VISIBILITY unsigned WINAPI
 __libcpp_beginthreadex_thunk(void *__raw_data)
 {
@@ -193,10 +513,32 @@ __libcpp_beginthreadex_thunk(void *__raw_data)
   return static_cast<unsigned>(reinterpret_cast<uintptr_t>(__func(__arg)));
 }
 
+#else // _WIN32_WINNT >= _WIN32_WINNT_VISTA
+
+static inline _LIBCPP_INLINE_VISIBILITY void
+__libcpp_tls_tss_dor_invoke();
+
+static inline _LIBCPP_INLINE_VISIBILITY unsigned WINAPI
+__libcpp_beginthreadex_thunk(void *__raw_data)
+{
+  auto *__data =
+      static_cast<__libcpp_beginthreadex_thunk_data *>(__raw_data);
+  auto *__func = __data->__func;
+  void *__arg = __data->__arg;
+  delete __data;
+  int ret;
+  ret = static_cast<unsigned>(reinterpret_cast<uintptr_t>(__func(__arg)));
+  __libcpp_tls_tss_dor_invoke();
+  return ret;
+}
+
+#endif // _WIN32_WINNT >= _WIN32_WINNT_VISTA
+
 bool __libcpp_thread_isnull(const __libcpp_thread_t *__t) {
   return *__t == 0;
 }
 
+#if !defined(_LIBCPP_MSVCRT)
 int __libcpp_thread_create(__libcpp_thread_t *__t, void *(*__func)(void *),
                            void *__arg)
 {
@@ -212,16 +554,39 @@ int __libcpp_thread_create(__libcpp_thread_t *__t, void *(*__func)(void *),
     return 0;
   return GetLastError();
 }
-
-__libcpp_thread_id __libcpp_thread_get_current_id()
+#else
+int __libcpp_thread_create(__libcpp_thread_t *__t, __libcpp_thread_id* __t_id,
+                           void *(*__func)(void *), void *__arg)
 {
-  return GetCurrentThreadId();
+  auto *__data = new __libcpp_beginthreadex_thunk_data;
+  __data->__func = __func;
+  __data->__arg = __arg;
+
+  unsigned __id;
+
+  *__t = reinterpret_cast<HANDLE>(_beginthreadex(nullptr, 0,
+                                                 __libcpp_beginthreadex_thunk,
+                                                 __data, 0, &__id));
+
+  *__t_id = __id;
+
+  if (*__t)
+    return 0;
+  return GetLastError();
 }
+#endif
 
+#if !defined(_LIBCPP_MSVCRT)
 __libcpp_thread_id __libcpp_thread_get_id(const __libcpp_thread_t *__t)
 {
   return GetThreadId(*__t);
 }
+#endif
+
+__libcpp_thread_id __libcpp_thread_get_current_id()
+{
+  return GetCurrentThreadId();
+}
 
 int __libcpp_thread_join(__libcpp_thread_t *__t)
 {
@@ -253,6 +618,7 @@ void __libcpp_thread_sleep_for(const chrono::nanoseconds& __ns)
 }
 
 // Thread Local Storage
+#if _WIN32_WINNT >= _WIN32_WINNT_VISTA
 int __libcpp_tls_create(__libcpp_tls_key* __key,
                         void(_LIBCPP_TLS_DESTRUCTOR_CC* __at_exit)(void*))
 {
@@ -275,7 +641,79 @@ int __libcpp_tls_set(__libcpp_tls_key __key, void *__p)
   return 0;
 }
 
+#else // _WIN32_WINNT >= _WIN32_WINNT_VISTA
+
+// https://devblogs.microsoft.com/oldnewthing/20160613-00/?p=93655
+// see also TLS_MINIMUM_AVAILABLE
+#define EMULATED_THREADS_TSS_DTOR_SLOTNUM 1024
+
+typedef void (*_LIBCPP_TLS_DESTRUCTOR_CC __libcpp_tls_dtor_t)(void *);
+
+static struct __libcpp_tls_tss_dor_entry {
+  __libcpp_tls_key key;
+  __libcpp_tls_dtor_t dtor;
+} __libcpp_tls_tss_dor_tbl[EMULATED_THREADS_TSS_DTOR_SLOTNUM];
+
+static inline _LIBCPP_INLINE_VISIBILITY int
+__libcpp_tls_tss_dor_register(__libcpp_tls_key key,
+                              __libcpp_tls_dtor_t dtor)
+{
+  int i;
+  for (i = 0; i < EMULATED_THREADS_TSS_DTOR_SLOTNUM; i++) {
+    if (!__libcpp_tls_tss_dor_tbl[i].dtor)
+      break;
+  }
+  if (i == EMULATED_THREADS_TSS_DTOR_SLOTNUM)
+    return 1;
+  __libcpp_tls_tss_dor_tbl[i].key = key;
+  __libcpp_tls_tss_dor_tbl[i].dtor = dtor;
+  return 0;
+}
+
+static inline _LIBCPP_INLINE_VISIBILITY void
+__libcpp_tls_tss_dor_invoke()
+{
+  int i;
+  for (i = 0; i < EMULATED_THREADS_TSS_DTOR_SLOTNUM; i++) {
+    if (__libcpp_tls_tss_dor_tbl[i].dtor) {
+      void* val = __libcpp_tls_get(__libcpp_tls_tss_dor_tbl[i].key);
+      if (val)
+        (__libcpp_tls_tss_dor_tbl[i].dtor)(val);
+    }
+  }
+}
+
+int __libcpp_tls_create(__libcpp_tls_key* __key,
+                        void(_LIBCPP_TLS_DESTRUCTOR_CC* __at_exit)(void*))
+{
+  DWORD index = TlsAlloc();
+  if (index == TLS_OUT_OF_INDEXES)
+    return GetLastError();
+  if (__libcpp_tls_tss_dor_register(index, __at_exit)) {
+    TlsFree(index);
+    return ERROR_INVALID_BLOCK;
+  }
+  *__key = index;
+  return 0;
+}
+
+void *__libcpp_tls_get(__libcpp_tls_key __key)
+{
+  return TlsGetValue(__key);
+}
+
+int __libcpp_tls_set(__libcpp_tls_key __key, void *__p)
+{
+  if (!TlsSetValue(__key, __p))
+    return GetLastError();
+  return 0;
+}
+
+#endif // _WIN32_WINNT >= _WIN32_WINNT_VISTA
+
 // Semaphores
+#if _WIN32_WINNT >= _WIN32_WINNT_VISTA
+
 bool __libcpp_semaphore_init(__libcpp_semaphore_t* __sem, int __init)
 {
   *(PHANDLE)__sem = CreateSemaphoreEx(nullptr, __init, _LIBCPP_SEMAPHORE_MAX,
@@ -283,6 +721,17 @@ bool __libcpp_semaphore_init(__libcpp_semaphore_t* __sem, int __init)
   return *__sem != nullptr;
 }
 
+#else // _WIN32_WINNT >= _WIN32_WINNT_VISTA
+
+bool __libcpp_semaphore_init(__libcpp_semaphore_t* __sem, int __init)
+{
+  *(PHANDLE)__sem = CreateSemaphore(nullptr, __init, _LIBCPP_SEMAPHORE_MAX,
+                                    nullptr);
+  return *__sem != nullptr;
+}
+
+#endif // _WIN32_WINNT >= _WIN32_WINNT_VISTA
+
 bool __libcpp_semaphore_destroy(__libcpp_semaphore_t* __sem)
 {
   CloseHandle(*(PHANDLE)__sem);
-- 
2.35.1

